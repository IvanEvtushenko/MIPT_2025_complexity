\section{Метрическая задача: 2-приближение}

\subsection{Алгоритм}

\begin{decision}

    \

    \textbf{Входные данные:} полный метрически-взвешенный граф $G = (V, E)$ (взвешенный граф $G = (V, E)$ в общем случае), вес. функция $\omega: E \rightarrow \mathbb{R}^{+}$, $V_0 \subset V$ - подмножество терминальных вершин.
    
    \
    
    \textbf{Выходные данные:} Дерево, содержащее все терминалы $V_0$.
    
    \
    
    \textbf{Операции:}
    \begin{enumerate}[leftmargin=50pt, itemsep=2pt, labelsep=6pt]\setcounter{enumi}{-1}
        \item Если граф не является полным метрически-взвешенным, привести его к соответствующему виду по алгоритму выше.
        \item Рассмотреть подграф на вершинах $V_0$.
        \item Вычислить по нему $\mathsf{MST}$ - минимальное остовное дерево.
        \item Вернуть $\mathsf{MST}$.
    \end{enumerate}
\end{decision}

\

\subsection{Корректность и оценка приближения}

\begin{proposition}
Пусть $T^*$ -- минимальное дерево Штейнера в метрическом графе. Тогда дерево, возвращаемое алгоритмом, имеет вес не больше чем $2\,\omega(T^*)$.
\end{proposition}

\begin{proof}
\par
Рассмотрим дерево $T^*$ и выполним по нему обход, не проходящий по одному ребру больше двух раз, начиная с произвольного терминала (это возможно, т.к. если удвоить все рёбра, то можно выделить эйлеров путь). Пусть полученный путь равен $l$, тогда
$$\omega(l) \leq 2 \omega(T^*).$$
Сославшись на индуцированную метрику допустимо перейти к рассмотрению $l$ только как набора прямых ребер между терм. вершинами, пусть на них индуцировано д.Ш. $T'$. $T'$ имеет вес равный $\omega(\mathsf{MST}(V_0))$, что есть не более чем $\omega(l), \text{ т.е. } \leq 2 \omega(T^*).$
\end{proof}

\subsection{Реализация алгоритма}

Реализация 2-приближения для метрического графа, работающая за $O\left(|V_0|^2 \log(|V_0|)\right)$:

\begin{lstlisting}[style=py]
import networkx as nx

def steiner_metric(G_m, V0):
    return nx.minimum_spanning_tree(G_m.subgraph(list(V0)))
\end{lstlisting}

\

Дополнение к предыдущей реализации для решения задачи, поставленной на классическом графе, работающее за $O\left(|V_0|^2 \log(|V_0|) + |V_0|\cdot|E| \log(|V|)\right)$:

\begin{lstlisting}[style=py]
def metric_closure(G, V0):
    R = list(V0)
    K = nx.Graph()
    K.add_nodes_from(R)
    P = {}
    for i, s in enumerate(R):
        d, path = nx.single_source_dijkstra(G, s)
        for t in R[i+1:]:
            K.add_edge(s, t, weight=d[t])
            P[s, t] = path[t]
            P[t, s] = path[t][::-1]
    return K, P

def steiner_common(G, V0):
    K, P = metric_closure(G, V0)
    Tt = steiner_metric(K, V0)
    H = nx.Graph()
    for u, v in Tt.edges():
        p = P[u, v]
        for a, b in zip(p, p[1:]):
            H.add_edge(a, b, weight=G[a][b].get("weight", 1))
    return nx.minimum_spanning_tree(H)
\end{lstlisting}

\subsection{Анализ алгоритма}

Для тестирования и анализа алгоритма был использован классический датасет, а точнее, его фрагмент I080~\cite{surs4}. Наибольший интерес представляют зависимости качества приближения и время работы от количества вершин и рёбер в графе. Протестировать на большом количестве вершин возможности нет (задача $\mathbf{NP}$-полна), поэтому ограничимся случаями для 6 и 8 терминальных вершин. 

\

\textbf{Результаты:}
\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.95\linewidth]{figures/fig_quality_time_m.pdf}
  \label{fig:qtime-m}
\end{figure}

\

\textbf{Выводы на основе результатов:}
\begin{enumerate}
    \item На малом количестве рёбер результатам алгоритма свойственна высокая дисперсия. С увеличением количества рёбер последняя резко падает и аппроксимационный результат стремится к $1.3$.
    \item С увеличением количества нетерминальных вершин точность алгоритма снижается вместе с увеличением дисперсии.
    \item Время работы алгоритма зависит от количества рёбер, что соответствует асимптотике алгоритма Дейкстры.
\end{enumerate}
